const e={},t={};for(let r=0;r<256;r++){let s=r.toString(16).toLowerCase();1===s.length&&(s=`0${s}`),e[r]=s,t[s]=r}function r(t){let r="";for(let s=0;s<t.byteLength;s++)r+=e[t[s]];return r}const s=e=>(new TextEncoder).encode(e),n=e=>"string"==typeof e?s(e):ArrayBuffer.isView(e)?new Uint8Array(e.buffer,e.byteOffset,e.byteLength/Uint8Array.BYTES_PER_ELEMENT):new Uint8Array(e),i="X-Amz-Date",a="X-Amz-Signature",o="X-Amz-Security-Token",c="authorization",g=i.toLowerCase(),h=[c,g,"date"],u=a.toLowerCase(),l="x-amz-content-sha256",d=o.toLowerCase(),y={authorization:!0,"cache-control":!0,connection:!0,expect:!0,from:!0,"keep-alive":!0,"max-forwards":!0,pragma:!0,referer:!0,te:!0,trailer:!0,"transfer-encoding":!0,upgrade:!0,"user-agent":!0,"x-amzn-trace-id":!0},f=/^proxy-/,p=/^sec-/,w="AWS4-HMAC-SHA256",m="AWS4-HMAC-SHA256-PAYLOAD",v="aws4_request",b={},S=[],A=(e,t,r)=>`${e}/${t}/${r}/${v}`,k=(e,t,r)=>{const s=new e(t);return s.update(n(r)),s.digest()},C=({headers:e},t,r)=>{const s={};for(const n of Object.keys(e).sort()){if(null==e[n])continue;const i=n.toLowerCase();(i in y||t?.has(i)||f.test(i)||p.test(i))&&(!r||r&&!r.has(i))||(s[i]=e[n].trim().replace(/\s+/g," "))}return s},$=async({headers:e,body:t},s)=>{for(const t of Object.keys(e))if(t.toLowerCase()===l)return e[t];if(null==t)return"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";if("string"==typeof t||ArrayBuffer.isView(t)||(i=t,"function"==typeof ArrayBuffer&&i instanceof ArrayBuffer||"[object ArrayBuffer]"===Object.prototype.toString.call(i))){const e=new s;return e.update(n(t)),r(await e.digest())}var i;return"UNSIGNED-PAYLOAD"};class q{format(e){const t=[];for(const r of Object.keys(e)){const n=s(r);t.push(Uint8Array.from([n.byteLength]),n,this.formatHeaderValue(e[r]))}const r=new Uint8Array(t.reduce((e,t)=>e+t.byteLength,0));let n=0;for(const e of t)r.set(e,n),n+=e.byteLength;return r}formatHeaderValue(e){switch(e.type){case"boolean":return Uint8Array.from([e.value?0:1]);case"byte":return Uint8Array.from([2,e.value]);case"short":const r=new DataView(new ArrayBuffer(3));return r.setUint8(0,3),r.setInt16(1,e.value,!1),new Uint8Array(r.buffer);case"integer":const n=new DataView(new ArrayBuffer(5));return n.setUint8(0,4),n.setInt32(1,e.value,!1),new Uint8Array(n.buffer);case"long":const i=new Uint8Array(9);return i[0]=5,i.set(e.value.bytes,1),i;case"binary":const a=new DataView(new ArrayBuffer(3+e.value.byteLength));a.setUint8(0,6),a.setUint16(1,e.value.byteLength,!1);const o=new Uint8Array(a.buffer);return o.set(e.value,3),o;case"string":const c=s(e.value),g=new DataView(new ArrayBuffer(3+c.byteLength));g.setUint8(0,7),g.setUint16(1,c.byteLength,!1);const h=new Uint8Array(g.buffer);return h.set(c,3),h;case"timestamp":const u=new Uint8Array(9);return u[0]=8,u.set(P.fromNumber(e.value.valueOf()).bytes,1),u;case"uuid":if(!E.test(e.value))throw new Error(`Invalid UUID received: ${e.value}`);const l=new Uint8Array(17);return l[0]=9,l.set(function(e){if(e.length%2!=0)throw new Error("Hex encoded strings must have an even number length");const r=new Uint8Array(e.length/2);for(let s=0;s<e.length;s+=2){const n=e.slice(s,s+2).toLowerCase();if(!(n in t))throw new Error(`Cannot decode unrecognized sequence ${n} as hexadecimal`);r[s/2]=t[n]}return r}(e.value.replace(/\-/g,"")),1),l}}}var D;!function(e){e[e.boolTrue=0]="boolTrue",e[e.boolFalse=1]="boolFalse",e[e.byte=2]="byte",e[e.short=3]="short",e[e.integer=4]="integer",e[e.long=5]="long",e[e.byteArray=6]="byteArray",e[e.string=7]="string",e[e.timestamp=8]="timestamp",e[e.uuid=9]="uuid"}(D||(D={}));const E=/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;class P{bytes;constructor(e){if(this.bytes=e,8!==e.byteLength)throw new Error("Int64 buffers must be exactly 8 bytes")}static fromNumber(e){if(e>0x8000000000000000||e<-0x8000000000000000)throw new Error(`${e} is too large (or, if negative, too small) to represent as an Int64`);const t=new Uint8Array(8);for(let r=7,s=Math.abs(Math.round(e));r>-1&&s>0;r--,s/=256)t[r]=s;return e<0&&R(t),new P(t)}valueOf(){const e=this.bytes.slice(0),t=128&e[0];return t&&R(e),parseInt(r(e),16)*(t?-1:1)}toString(){return String(this.valueOf())}}function R(e){for(let t=0;t<8;t++)e[t]^=255;for(let t=7;t>-1&&(e[t]++,0===e[t]);t--);}class j{method;protocol;hostname;port;path;query;headers;username;password;fragment;body;constructor(e){this.method=e.method||"GET",this.hostname=e.hostname||"localhost",this.port=e.port,this.query=e.query||{},this.headers=e.headers||{},this.body=e.body,this.protocol=e.protocol?":"!==e.protocol.slice(-1)?`${e.protocol}:`:e.protocol:"https:",this.path=e.path?"/"!==e.path.charAt(0)?`/${e.path}`:e.path:"/",this.username=e.username,this.password=e.password,this.fragment=e.fragment}static clone(e){const t=new j({...e,headers:{...e.headers}});var r;return t.query&&(t.query=(r=t.query,Object.keys(r).reduce((e,t)=>{const s=r[t];return{...e,[t]:Array.isArray(s)?[...s]:s}},{}))),t}static isInstance(e){if(!e)return!1;const t=e;return"method"in t&&"protocol"in t&&"hostname"in t&&"path"in t&&"object"==typeof t.query&&"object"==typeof t.headers}clone(){return j.clone(this)}}const L=e=>{e=j.clone(e);for(const t of Object.keys(e.headers))h.indexOf(t.toLowerCase())>-1&&delete e.headers[t];return e},U=e=>{if("function"==typeof e)return e;const t=Promise.resolve(e);return()=>t},O=e=>encodeURIComponent(e).replace(/[!'()*]/g,x),x=e=>`%${e.charCodeAt(0).toString(16).toUpperCase()}`;class T{service;regionProvider;credentialProvider;sha256;uriEscapePath;applyChecksum;constructor({applyChecksum:e,credentials:t,region:r,service:s,sha256:n,uriEscapePath:i=!0}){this.service=s,this.sha256=n,this.uriEscapePath=i,this.applyChecksum="boolean"!=typeof e||e,this.regionProvider=U(r),this.credentialProvider=U(t)}createCanonicalRequest(e,t,r){const s=Object.keys(t).sort();return`${e.method}\n${this.getCanonicalPath(e)}\n${(({query:e={}})=>{const t=[],r={};for(const s of Object.keys(e)){if(s.toLowerCase()===u)continue;const n=O(s);t.push(n);const i=e[s];"string"==typeof i?r[n]=`${n}=${O(i)}`:Array.isArray(i)&&(r[n]=i.slice(0).reduce((e,t)=>e.concat([`${n}=${O(t)}`]),[]).sort().join("&"))}return t.sort().map(e=>r[e]).filter(e=>e).join("&")})(e)}\n${s.map(e=>`${e}:${t[e]}`).join("\n")}\n\n${s.join(";")}\n${r}`}async createStringToSign(e,t,s,i){const a=new this.sha256;return a.update(n(s)),`${i}\n${e}\n${t}\n${r(await a.digest())}`}getCanonicalPath({path:e}){if(this.uriEscapePath){const t=[];for(const r of e.split("/"))0!==r?.length&&"."!==r&&(".."===r?t.pop():t.push(r));const r=`${e?.startsWith("/")?"/":""}${t.join("/")}${t.length>0&&e?.endsWith("/")?"/":""}`;return O(r).replace(/%2F/g,"/")}return e}validateResolvedCredentials(e){if("object"!=typeof e||"string"!=typeof e.accessKeyId||"string"!=typeof e.secretAccessKey)throw new Error("Resolved credential object is not valid")}formatDate(e){const t=(r=e,(e=>"number"==typeof e?new Date(1e3*e):"string"==typeof e?Number(e)?new Date(1e3*Number(e)):new Date(e):e)(r).toISOString().replace(/\.\d{3}Z$/,"Z")).replace(/[\-:]/g,"");var r;return{longDate:t,shortDate:t.slice(0,8)}}getCanonicalHeaderList(e){return Object.keys(e).sort().join(";")}}class H extends T{headerFormatter=new q;constructor({applyChecksum:e,credentials:t,region:r,service:s,sha256:n,uriEscapePath:i=!0}){super({applyChecksum:e,credentials:t,region:r,service:s,sha256:n,uriEscapePath:i})}async presign(e,t={}){const{signingDate:r=new Date,expiresIn:s=3600,unsignableHeaders:n,unhoistableHeaders:c,signableHeaders:g,hoistableHeaders:h,signingRegion:u,signingService:l}=t,d=await this.credentialProvider();this.validateResolvedCredentials(d);const y=u??await this.regionProvider(),{longDate:f,shortDate:p}=this.formatDate(r);if(s>604800)return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");const m=A(p,y,l??this.service),v=((e,t={})=>{const{headers:r,query:s={}}=j.clone(e);for(const e of Object.keys(r)){const n=e.toLowerCase();("x-amz-"===n.slice(0,6)&&!t.unhoistableHeaders?.has(n)||t.hoistableHeaders?.has(n))&&(s[e]=r[e],delete r[e])}return{...e,headers:r,query:s}})(L(e),{unhoistableHeaders:c,hoistableHeaders:h});d.sessionToken&&(v.query[o]=d.sessionToken),v.query["X-Amz-Algorithm"]=w,v.query["X-Amz-Credential"]=`${d.accessKeyId}/${m}`,v.query[i]=f,v.query["X-Amz-Expires"]=s.toString(10);const b=C(v,n,g);return v.query["X-Amz-SignedHeaders"]=this.getCanonicalHeaderList(b),v.query[a]=await this.getSignature(f,m,this.getSigningKey(d,y,p,l),this.createCanonicalRequest(v,b,await $(e,this.sha256))),v}async sign(e,t){return"string"==typeof e?this.signString(e,t):e.headers&&e.payload?this.signEvent(e,t):e.message?this.signMessage(e,t):this.signRequest(e,t)}async signEvent({headers:e,payload:t},{signingDate:s=new Date,priorSignature:n,signingRegion:i,signingService:a}){const o=i??await this.regionProvider(),{shortDate:c,longDate:g}=this.formatDate(s),h=A(c,o,a??this.service),u=await $({headers:{},body:t},this.sha256),l=new this.sha256;l.update(e);const d=r(await l.digest()),y=[m,g,h,n,d,u].join("\n");return this.signString(y,{signingDate:s,signingRegion:o,signingService:a})}async signMessage(e,{signingDate:t=new Date,signingRegion:r,signingService:s}){return this.signEvent({headers:this.headerFormatter.format(e.message.headers),payload:e.message.body},{signingDate:t,signingRegion:r,signingService:s,priorSignature:e.priorSignature}).then(t=>({message:e.message,signature:t}))}async signString(e,{signingDate:t=new Date,signingRegion:s,signingService:i}={}){const a=await this.credentialProvider();this.validateResolvedCredentials(a);const o=s??await this.regionProvider(),{shortDate:c}=this.formatDate(t),g=new this.sha256(await this.getSigningKey(a,o,c,i));return g.update(n(e)),r(await g.digest())}async signRequest(e,{signingDate:t=new Date,signableHeaders:r,unsignableHeaders:s,signingRegion:n,signingService:i}={}){const a=await this.credentialProvider();this.validateResolvedCredentials(a);const o=n??await this.regionProvider(),h=L(e),{longDate:u,shortDate:y}=this.formatDate(t),f=A(y,o,i??this.service);h.headers[g]=u,a.sessionToken&&(h.headers[d]=a.sessionToken);const p=await $(h,this.sha256);!((e,t)=>{e=e.toLowerCase();for(const r of Object.keys(t))if(e===r.toLowerCase())return!0;return!1})(l,h.headers)&&this.applyChecksum&&(h.headers[l]=p);const m=C(h,s,r),v=await this.getSignature(u,f,this.getSigningKey(a,o,y,i),this.createCanonicalRequest(h,m,p));return h.headers[c]=`${w} Credential=${a.accessKeyId}/${f}, SignedHeaders=${this.getCanonicalHeaderList(m)}, Signature=${v}`,h}async getSignature(e,t,s,i){const a=await this.createStringToSign(e,t,i,w),o=new this.sha256(await s);return o.update(n(a)),r(await o.digest())}getSigningKey(e,t,s,n){return(async(e,t,s,n,i)=>{const a=`${s}:${n}:${i}:${r(await k(e,t.secretAccessKey,t.accessKeyId))}:${t.sessionToken}`;if(a in b)return b[a];for(S.push(a);S.length>50;)delete b[S.shift()];let o=`AWS4${t.secretAccessKey}`;for(const t of[s,n,i,v])o=await k(e,o,t);return b[a]=o})(this.sha256,e,s,t,n||this.service)}}var I;!function(e){e.ENV="env",e.CONFIG="shared config entry"}(I||(I={}));const V="X-Amz-S3session-Token",K=V.toLowerCase();class z extends H{async signWithCredentials(e,t,r){const s=W(t);return e.headers[K]=t.sessionToken,F(this,s),this.signRequest(e,r??{})}async presignWithCredentials(e,t,r){const s=W(t);return delete e.headers[K],e.headers[V]=t.sessionToken,e.query=e.query??{},e.query[V]=t.sessionToken,F(this,s),this.presign(e,r)}}function W(e){return{accessKeyId:e.accessKeyId,secretAccessKey:e.secretAccessKey,expiration:e.expiration}}function F(e,t){const r=setTimeout(()=>{throw new Error("SignatureV4S3Express credential override was created but not called.")},10),s=e.credentialProvider;e.credentialProvider=()=>(clearTimeout(r),e.credentialProvider=s,Promise.resolve(t))}const M={CrtSignerV4:null};class B{sigv4aSigner;sigv4Signer;signerOptions;constructor(e){this.sigv4Signer=new z(e),this.signerOptions=e}async sign(e,t={}){return"*"===t.signingRegion?this.getSigv4aSigner().sign(e,t):this.sigv4Signer.sign(e,t)}async signWithCredentials(e,t,r={}){if("*"===r.signingRegion){const s=this.getSigv4aSigner(),n=M.CrtSignerV4;if(n&&s instanceof n)return s.signWithCredentials(e,t,r);throw new Error('signWithCredentials with signingRegion \'*\' is only supported when using the CRT dependency @aws-sdk/signature-v4-crt. Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt')}return this.sigv4Signer.signWithCredentials(e,t,r)}async presign(e,t={}){if("*"===t.signingRegion){const r=this.getSigv4aSigner(),s=M.CrtSignerV4;if(s&&r instanceof s)return r.presign(e,t);throw new Error('presign with signingRegion \'*\' is only supported when using the CRT dependency @aws-sdk/signature-v4-crt. Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt')}return this.sigv4Signer.presign(e,t)}async presignWithCredentials(e,t,r={}){if("*"===r.signingRegion)throw new Error("Method presignWithCredentials is not supported for [signingRegion=*].");return this.sigv4Signer.presignWithCredentials(e,t,r)}getSigv4aSigner(){if(!this.sigv4aSigner){const e=M.CrtSignerV4,t=null;if("node"===this.signerOptions.runtime){if(!e&&!t)throw new Error("Neither CRT nor JS SigV4a implementation is available. Please load either @aws-sdk/signature-v4-crt or @aws-sdk/signature-v4a. For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt");if(e&&"function"==typeof e)this.sigv4aSigner=new e({...this.signerOptions,signingAlgorithm:1});else{if(!t||"function"!=typeof t)throw new Error("Available SigV4a implementation is not a valid constructor. Please ensure you've properly imported @aws-sdk/signature-v4-crt or @aws-sdk/signature-v4a.For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt");this.sigv4aSigner=new t({...this.signerOptions})}}else{if(!t||"function"!=typeof t)throw new Error("JS SigV4a implementation is not available or not a valid constructor. Please check whether you have installed the @aws-sdk/signature-v4a package explicitly. The CRT implementation is not available for browsers. You must also register the package by calling [require('@aws-sdk/signature-v4a');] or an ESM equivalent such as [import '@aws-sdk/signature-v4a';]. For more information please go to https://github.com/aws/aws-sdk-js-v3#using-javascript-non-crt-implementation-of-sigv4a");this.sigv4aSigner=new t({...this.signerOptions})}}return this.sigv4aSigner}}export{B as SignatureV4MultiRegion,M as signatureV4CrtContainer};